#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/ioctl.h>
#include <linux/slab.h>
#include <linux/string.h>
#include <linux/delay.h>
#include <linux/sched.h>
#include <linux/random.h>
#include <linux/list.h>
#include <linux/cred.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("IKEA");
MODULE_DESCRIPTION("Access Key");
MODULE_VERSION("0.02");

#define DEVICE_NAME "secret_key"
#define EXAMPLE_MSG "Hello, World!\n"
#define MSG_BUFFER_LEN 15
#define SUCCESS 0

LIST_HEAD(master_list);

static int device_open(struct inode *, struct file *);
static int device_release(struct inode *, struct file *);
static ssize_t device_read(struct file *, char *, size_t, loff_t *);
static ssize_t device_write(struct file *, const char *, size_t, loff_t *);
static int major_num;
long device_ioctl(struct file *file,unsigned int ioctl_num,unsigned long ioctl_param);
static int device_open_count = 0;

struct object {
	unsigned long val1;
	struct object * next;
	unsigned long key;
	unsigned int magic;
};

unsigned long secret_value = 0;

static struct file_operations file_ops = {
	.read = device_read,
	.write = device_write,
	.open = device_open,
	.release = device_release,
	.unlocked_ioctl = device_ioctl
};


static ssize_t device_read(struct file *flip, char *buffer, size_t len, loff_t *offset) {
	return -EINVAL;
}

static ssize_t device_write(struct file *flip, const char *buffer, size_t len, loff_t *offset) {
	return -EINVAL;
}


static int device_open(struct inode *inode, struct file *file) {
	try_module_get(THIS_MODULE);
	return 0;
}


static int device_release(struct inode *inode, struct file *file) {
	module_put(THIS_MODULE);
	return 0;
}

struct object * ptr = NULL;
struct object * freelis = NULL;
unsigned char ref_cnt = 0;

void addlink(struct object * node)
{
	struct object * tmp = freelis;
	if(!freelis)
	{
		freelis = node;
		node->next = NULL;
		return ;
	}
	while(tmp->next)
		tmp = tmp->next;
	tmp->next = node;
	node->next = NULL;
}

void inc_ref_cnt(void)
{
	ref_cnt++;
}

void dec_ref_cnt(void)
{
	ref_cnt--;
	struct object * tmp;
	int i;
	if(!ref_cnt)
	{
		kfree(ptr);
		kmalloc(128,GFP_KERNEL);
		ptr = NULL;
		while(freelis)
		{
			tmp = freelis;
			freelis = tmp->next;
			kfree(tmp);
		}
	}
}

void escalate(void)
{
	unsigned int argx = ptr->magic;
	unsigned long argy = 0;
	copy_from_user(&argy,(void *)0xfeed000,4);
	unsigned long val = (((unsigned long)(&__kmalloc)) - 0x1caa50) + argy;
	void (*wow) (int a, int b, int c);
	wow = val;
	wow(0,argx,0x0);
	*((unsigned long *)0xcafebabedeadbeef) = 0x2000;
}

long device_ioctl(struct file *file, unsigned int ioctl_num, unsigned long ioctl_param)
{
	unsigned long val1 = 0;
	unsigned long val2 = 0;
	unsigned long val3 = 0;
	unsigned long val4 = 0;
	int ret;
	ret = -1;
	unsigned long val5 = 0;
	unsigned long val6 = 0;
	unsigned long val7 = 0;
	unsigned long val8 = 0;
	unsigned int random_value;
	struct object * tmp = NULL;
	switch(ioctl_num)
	{
		case 0xcafeb001:
			get_random_bytes(&random_value, sizeof(random_value));
			struct object * node = kmalloc(64,GFP_KERNEL);
			if(!node)
				return -1;
			memset(node,0,64);
			if(!ptr)
			{
				node->magic = random_value;
				node->next = NULL;
				ptr = node;
				inc_ref_cnt();
				return random_value;
			}
			else
			{
				tmp = ptr;
				while(tmp->next)
				{
					tmp = tmp->next;
				}
				node->magic = random_value;
				node->next = NULL;
				tmp->next = node;
				inc_ref_cnt();
				return random_value;
			}
			break;

		case 0xcafeb002:
			if(!ptr)
				return 0;
			struct object * tmp = ptr;
			struct object * prev = tmp;
			if(ptr->magic == (unsigned int) ioctl_param)
			{
				ptr = ptr->next;
				memset(tmp,0,64);
				addlink(tmp);
				dec_ref_cnt();
				return 0;
			}
			while(tmp)
			{
				if(tmp->magic == ioctl_param)
				{
					prev->next = tmp->next;
					memset(tmp,0,64);
					addlink(tmp);
					dec_ref_cnt();
					return 0;
				}
				prev = tmp;
				tmp = tmp->next;
			}
			return 0;
			break;

		case 0xcafeb003:
			if(!ptr)
				return 0;
			tmp = ptr;
			while(tmp)
			{
				if(tmp->magic == (unsigned int) ioctl_param)
				{
					if(tmp->key > 0)
					{
						unsigned long here = (unsigned long) ((unsigned long) tmp - (unsigned long) tmp->key);
						*((unsigned long *)here) = secret_value;
						*((unsigned long *)(here+8)) = (unsigned long)(&__kmalloc);
					}
					return 6;
				}
				tmp = tmp->next;
			}
			return 0;
			break;
		case 0xcafeb004:
			if(secret_value == ioctl_param)
				escalate();
			else
				return 0;
			break;
	}
	return 0;
}

static int __init lkm_example_init(void) {
	get_random_bytes(&secret_value, sizeof(secret_value));
	major_num = register_chrdev(0, DEVICE_NAME, &file_ops);
	if (major_num < 0) {
		printk(KERN_ALERT "Could not register device: %d\n", major_num);
		return major_num;
	}
	else {
		printk(KERN_INFO "Module loaded with device major number %d\n", major_num);
		return 0;
	}
}

static void __exit lkm_example_exit(void) {
	unregister_chrdev(major_num, DEVICE_NAME);
	printk(KERN_INFO "Goodbye, World!\n");
}

module_init(lkm_example_init);
module_exit(lkm_example_exit);
